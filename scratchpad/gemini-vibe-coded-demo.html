<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Balls Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #111827; /* bg-gray-900 */
        }
        #game-container, canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #game-container {
            background-color: #1f2937; /* bg-gray-800 */
            border-radius: 1.5rem; /* rounded-3xl */
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        input[type=range] {
            -webkit-appearance: none; appearance: none; width: 100%; height: 8px;
            background: #4b5563; border-radius: 5px; outline: none; opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover { opacity: 1; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 24px; height: 24px;
            background: #3b82f6; cursor: pointer; border-radius: 50%; border: 2px solid white;
        }
        input[type=range]::-moz-range-thumb {
            width: 24px; height: 24px; background: #3b82f6; cursor: pointer;
            border-radius: 50%; border: 2px solid white;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="flex flex-col md:flex-row w-screen h-screen p-4 md:p-8 gap-8">
        
        <div id="game-container" class="w-full md:w-1/2 h-1/2 md:h-full">
            <!-- Canvas inserted here -->
        </div>

        <div class="w-full md:w-1/2 h-1/2 md:h-full flex flex-col items-center justify-center">
            <div class="w-full max-w-sm flex flex-col gap-6">
                <div class="text-center">
                    <h1 class="text-4xl lg:text-5xl font-bold text-white">Ball Fall</h1>
                    <p class="text-gray-400 mt-2">An endless race to the bottom!</p>
                </div>

                <div class="p-6 bg-gray-800 rounded-3xl shadow-lg">
                    <label for="ball-count-slider" class="block mb-2 font-semibold text-lg">Number of Balls: <span id="ball-count-value" class="font-bold text-blue-400">8</span></label>
                    <input id="ball-count-slider" type="range" min="2" max="15" value="8" class="w-full">
                </div>
                
                <button id="start-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-xl transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-400 focus:ring-opacity-50 text-xl shadow-lg">
                    Start Race
                </button>

                <div id="winner-message-container" class="text-center p-4 bg-gray-700 rounded-xl h-24 flex items-center justify-center transition-opacity duration-500 opacity-0">
                    <p id="winner-message" class="text-lg font-semibold"></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

        const gameContainer = document.getElementById('game-container');
        const ballCountSlider = document.getElementById('ball-count-slider');
        const ballCountValue = document.getElementById('ball-count-value');
        const startButton = document.getElementById('start-button');
        const winnerMessageContainer = document.getElementById('winner-message-container');
        const winnerMessage = document.getElementById('winner-message');

        let width, height, ballSize;
        let engine, render, runner;
        let balls = [], obstacles = [], animatedObstacles = [];
        let gameOver = false, winningBall = null;
        
        let cameraY = 0;
        let lastGeneratedY = 0;
        const generationThreshold = 500;
        const cleanupThreshold = 1000;
        const finishLineY = 8000;

        const ballColors = [
            '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', '#22c55e', 
            '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1', 
            '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e'
        ];

        function init() {
            engine = Engine.create();
            engine.world.gravity.y = 1.2;

            render = Render.create({
                element: gameContainer,
                engine: engine,
                options: { wireframes: false, background: 'transparent' }
            });

            runner = Runner.create();
            Render.run(render);
            
            setupEventListeners();
            handleResize(); 
        }

        function setupEventListeners() {
            ballCountSlider.addEventListener('input', (e) => { ballCountValue.textContent = e.target.value; });
            startButton.addEventListener('click', resetGame);
            Events.on(engine, 'afterUpdate', updateGame);
            Events.on(render, 'afterRender', customRenderLoop);
            window.addEventListener('resize', handleResize);
        }

        function handleResize() {
            if (runner) Runner.stop(runner);
            
            width = gameContainer.clientWidth;
            height = gameContainer.clientHeight;

            render.options.width = width;
            render.options.height = height;
            render.canvas.width = width;
            render.canvas.height = height;

            ballSize = Math.max(10, Math.min(14, width / 30));
            resetGame();
        }

        function resetGame() {
            if (runner.enabled) Runner.stop(runner);
            gameOver = false;
            winningBall = null;
            cameraY = 0;
            lastGeneratedY = 0;

            World.clear(engine.world);
            balls = [];
            obstacles = [];
            animatedObstacles = [];

            winnerMessageContainer.style.opacity = '0';
            winnerMessage.textContent = '';

            createEnvironment();
            generateWorldChunks(0, height * 2);
            createBalls(parseInt(ballCountSlider.value));

            Runner.run(runner, engine);
        }

        function createEnvironment() {
            const wallOptions = { isStatic: true, render: { fillStyle: '#4b5563' } };
            const thickness = 50;
            World.add(engine.world, [
                Bodies.rectangle(width / 2, -thickness / 2, width, thickness, wallOptions),
                Bodies.rectangle(-thickness / 2, finishLineY/2, thickness, finishLineY, wallOptions),
                Bodies.rectangle(width + thickness / 2, finishLineY/2, thickness, finishLineY, wallOptions)
            ]);
        }
        
        function generateWorldChunks(startY, endY) {
            for (let y = startY; y < endY; y += height / 2) {
                const scenarioType = Math.floor(Math.random() * 3);
                switch (scenarioType) {
                    case 0: createPlinkoBoard(y); break;
                    case 1: createMovingBars(y); break;
                    case 2: createFunnels(y); break;
                }
            }
            lastGeneratedY = endY;
        }

        function cleanupOldObstacles() {
            const viewTop = render.bounds.min.y;
            const toRemoveBodies = obstacles.filter(obs => obs.position.y < viewTop - cleanupThreshold);
            if(toRemoveBodies.length > 0) {
                World.remove(engine.world, toRemoveBodies);
                obstacles = obstacles.filter(obs => !toRemoveBodies.includes(obs));
                animatedObstacles = animatedObstacles.filter(anim => !toRemoveBodies.includes(anim.body));
            }
        }

        function createBallTexture(number, color, radius) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const diameter = radius * 2;
            canvas.width = diameter;
            canvas.height = diameter;

            context.fillStyle = color;
            context.beginPath();
            context.arc(radius, radius, radius, 0, 2 * Math.PI);
            context.fill();

            context.font = `bold ${radius}px Inter`;
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(number, radius, radius);

            return canvas.toDataURL();
        }

        function createBalls(count) {
            const startX = width / 2;
            const startY = 50;
            let availableColors = [...ballColors];

            for (let i = 0; i < count; i++) {
                if (availableColors.length === 0) availableColors = [...ballColors];
                const color = availableColors.splice(Math.floor(Math.random() * availableColors.length), 1)[0];
                const number = i + 1;
                const texture = createBallTexture(number, color, ballSize);

                const ball = Bodies.circle(
                    startX + (Math.random() - 0.5) * (width * 0.4),
                    startY + (Math.random() - 0.5) * 40,
                    ballSize, {
                        restitution: 0.4, 
                        friction: 0.01,
                        label: `Ball ${number}`,
                        render: {
                            sprite: {
                                texture: texture
                            }
                        }
                    }
                );
                balls.push(ball);
            }
            World.add(engine.world, balls);
        }

        function createPlinkoBoard(offsetY) {
            const pinOptions = { isStatic: true, render: { fillStyle: '#9ca3af' }, friction: 0.05 };
            const rows = 5;
            const cols = Math.floor(width / 50);
            const pinSize = Math.max(2, width / 90);
            const spacingY = height / rows / 2;
            const spacingX = width / (cols + 1);
            let newPins = [];

            for (let row = 0; row < rows; row++) {
                const currentCols = cols + (row % 2);
                for (let col = 0; col < currentCols; col++) {
                    const x = spacingX * (col + 1) - (row % 2 === 0 ? spacingX / 2 : 0);
                    const y = offsetY + 100 + row * spacingY;
                    if (x > width - pinSize || x < pinSize) continue;
                    
                    const pin = Bodies.circle(x, y, pinSize, pinOptions);
                    if (Math.random() < 0.15) {
                        animatedObstacles.push({
                            body: pin, type: 'horizontal-oscillation', initialX: pin.position.x,
                            speed: 0.0015 * (Math.random() + 0.5), range: 25 * (Math.random() + 0.5)
                        });
                    }
                    obstacles.push(pin);
                    newPins.push(pin);
                }
            }
            World.add(engine.world, newPins);
        }

        function createMovingBars(offsetY) {
            const barOptions = { isStatic: true, render: { fillStyle: '#60a5fa' }};
            const barWidth = width * 0.6;
            const barHeight = Math.max(10, height / 40);
            const bar1 = Bodies.rectangle(width / 4, offsetY + height * 0.15, barWidth, barHeight, {...barOptions, angle: (Math.random() - 0.5) * 0.1});
            const bar2 = Bodies.rectangle(width * 3 / 4, offsetY + height * 0.35, barWidth, barHeight, {...barOptions, angle: (Math.random() - 0.5) * 0.1});
            
            obstacles.push(bar1, bar2);
            World.add(engine.world, [bar1, bar2]);
            
            const movementRange = (width - barWidth) / 2;
            animatedObstacles.push({
                body: bar1, type: 'horizontal-oscillation', initialX: width/2,
                speed: 0.001, range: movementRange
            });
            animatedObstacles.push({
                body: bar2, type: 'horizontal-oscillation', initialX: width/2,
                speed: -0.0012, range: movementRange
            });
        }

        function createFunnels(offsetY) {
            const funnelOptions = { isStatic: true, render: { fillStyle: '#34d399' } };
            const angle = 0.4;
            const funnelWidth = width / 2;
            const funnelHeight = Math.max(8, height / 60);
            const newFunnels = [
                Bodies.rectangle(width * 0.25, offsetY + height * 0.1, funnelWidth, funnelHeight, { ...funnelOptions, angle: -angle }),
                Bodies.rectangle(width * 0.75, offsetY + height * 0.1, funnelWidth, funnelHeight, { ...funnelOptions, angle: angle }),
                Bodies.rectangle(width * 0.5, offsetY + height * 0.3, width / 3, funnelHeight, { ...funnelOptions, angle: (Math.random() - 0.5) * 0.15 })
            ];
            
            obstacles.push(...newFunnels);
            World.add(engine.world, newFunnels);

            // Give the funnels a horizontal sliding motion to prevent balls from getting stuck
            animatedObstacles.push({
                body: newFunnels[0], type: 'horizontal-oscillation', initialX: newFunnels[0].position.x,
                speed: 0.002, range: 20
            });
            animatedObstacles.push({
                body: newFunnels[1], type: 'horizontal-oscillation', initialX: newFunnels[1].position.x,
                speed: -0.002, range: 20
            });
        }

        function updateGame() {
            if (gameOver) return;

            const time = engine.timing.timestamp;
            for (const anim of animatedObstacles) {
                if (anim.type === 'horizontal-oscillation') {
                    Body.setPosition(anim.body, {
                        x: anim.initialX + Math.sin(time * anim.speed) * anim.range,
                        y: anim.body.position.y
                    });
                }
            }

            let lowestBall = balls[0];
            if (!lowestBall) return;
            for (let i = 1; i < balls.length; i++) {
                if (balls[i].position.y > lowestBall.position.y) {
                    lowestBall = balls[i];
                }
            }

            const targetY = lowestBall.position.y - height / 3;
            cameraY += (targetY - cameraY) * 0.05;
            
            Render.lookAt(render, {
                min: { x: 0, y: cameraY },
                max: { x: width, y: cameraY + height }
            });

            if (lowestBall.position.y > lastGeneratedY - generationThreshold) {
                generateWorldChunks(lastGeneratedY, lastGeneratedY + height);
                cleanupOldObstacles();
            }

            if (lowestBall.position.y > finishLineY) {
                gameOver = true;
                winningBall = lowestBall;
                Runner.stop(runner);
                winnerMessageContainer.style.opacity = '1';
                const winnerColor = winningBall.render.sprite.texture.split(',')[0].split(':')[1];
                winnerMessage.innerHTML = `The <span style="color:${winnerColor}; font-weight: 900;">WINNER</span> is ${winningBall.label}!`;
            }
        }

        function customRenderLoop() {
            if (!gameOver || !winningBall) return;
            
            const ctx = render.context;
            const targetY = winningBall.position.y - height / 2;
            cameraY += (targetY - cameraY) * 0.05;
             Render.lookAt(render, {
                min: { x: 0, y: cameraY },
                max: { x: width, y: cameraY + height }
            });

            ctx.beginPath();
            ctx.arc(winningBall.position.x, winningBall.position.y, ballSize + 10, 0, 2 * Math.PI);
            ctx.strokeStyle = '#facc15';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#facc15';
            ctx.shadowBlur = 20;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        window.onload = init;
    </script>
</body>
</html>
